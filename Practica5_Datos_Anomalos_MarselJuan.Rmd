---
title: "Práctica 5. Datos Anómalos"
subtitle: "Análisis Exploratorio de Datos, Máster en Ciencia de Datos - UV"
output:
  html_document:
    echo: yes
    number_sections: no
    theme: lumen
    toc: yes
  pdf_document:
    toc: yes
    toc_depth: 3
    number_sections: no
---

```{r setup, cache = F, echo = F, message = F, warning = F, tidy = F}
# CONFIGURACIÓN GENERAL
library(knitr)
options(width = 100)
# Opciones generales chunks
opts_chunk$set(echo = T, message = F, error = F, warning = F,
               comment = NA, fig.align = 'center', dpi = 100, tidy = F,
               cache.path = '.cache/', fig.path = './figure/')
# options(xtable.type = 'html')
knit_hooks$set(inline = function(x) {
  if(is.numeric(x)) {
    round(x, getOption('digits'))
  } else {
    paste(as.character(x), collapse = ', ')
  }
})
# knit_hooks$set(plot = knitr:::hook_plot_html)
knitr::opts_chunk$set(fig.width=8, fig.height=4)
```


```{r}
library(pacman)
packages = c("knitr", "ggplot2","tidyr","dplyr","readr")
pacman::p_load(char=packages)

```

```{r Solucion opciones visualizacion, eval=F, include=F}
# {r Solucion ejercicio xxx, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE} 
# para generar nuestra versión con todas las soluciones.
# {r Solucion ejercicio xxx, include=TRUE, echo=FALSE, eval=TRUE, results= FALSE}
# para generar su versión sin código ni resultados numéricos pero con las gráficas.
```


# Introducción y objetivos

El objetivo de esta práctica es comprobar si los conjuntos de datos con los que vamos a trabajar son consistentes y, por tanto, pueden ser empleados para realizar un análisis sin errores.
Las observaciones contenidas en los datos pueden presentar diferentes tipos de inconsistencias, como valores perdidos (missing values), valores especiales y valores anómalos (outliers).

Para evitar estas inconsistencias, estos datos deberán ser eliminados, corregidos o imputados. Siendo las etapas que pueden seguirse para obtener datos consistentes:

  1. Detección de las inconsistencias.
  2. Detectar el campo o campos que la generan y las dependencias entre ellos.
  3. Corrección de errores.

Vamos a trabajar con el conjunto de datos *dirty_iris*, que ya conocemos, que contiene datos perdidos, valores especiales y anomalías de carácter numérico respecto a la distribución de los datos (``dirty_iris.csv``).

```{r}
rm(list=ls())
dirty_iris <- read_csv("data/dirty_iris.csv")
```

# Detección de inconsistencias en los datos

Por lo general, no hay un convenio o una representación común para indicar un dato perdido o incluso determinados valores especiales. En los siguientes ejercicios vamos a analizar cómo detectar inconsistencias presentes en los datos.

## Ejercicio 1: Inspección Visual

Inspecciona visualmente los valores del conjunto de datos (`View`) y ordena de mayor a menor y de menor a mayor cada variable para descubrir las diferentes inconsistencias que presenta el conjunto `dirty_iris`. Comenta los valores que te llamen la atención.

```{r Solucion ejercicio 1, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}
# Medidas con valores faltantes, longitudes negativas y cero

#View(dirty_iris)

#de mayor a menor -- desc()
dirty_iris %>%
  arrange(desc(Sepal.Length))

#de menor a mayor
dirty_iris %>%
  arrange(Sepal.Length) 

dirty_iris %>%
  arrange(Petal.Length) 

dirty_iris %>%
  arrange(desc(Petal.Length))

#de mayor a menor -- desc()
dirty_iris %>%
  arrange(desc(Sepal.Width)) 

#de menor a mayor
dirty_iris %>%
  arrange(Sepal.Width) 

#de mayor a menor -- desc()
dirty_iris %>%
  arrange(desc(Petal.Width)) 

#de menor a mayor
dirty_iris %>%
  arrange(Petal.Width) 

# Ver valores únicos
table(dirty_iris$Species)
```
Aparecen medidas negativas como -5.1 o -0.3 lo cual no tiene sentido, ya que las longitudes y anchos de partes de una flor (pétalos, sépalos) no pueden ser negativos. 

También observamos valores 0 que, al igual que los negativos, es imposible que una flor tenga un pétalo o sépalo con una medida de cero.

Por otro lado, también podemos observar valores atípicos desproporcionadamente grandes (por ejemplo, 73 en lugar de un valor esperado como 7.3, dentro del rango del resto de valores). Seguramente se debe a un error en el ingreso de los datos.

Al ordenar de mayor a menor, los valores NA se agrupan al final indicando que para varias flores, no se registró una o más de sus medidas.


## Ejercicio 2: Valores especiales

Visualizar los datos puede ser muy revelador, pero en general, especialmente para conjuntos de datos grandes, realizaremos este análisis de forma automática.

Los valores especiales más comunes en R son:

  * NA (_not available_): missing value o dato perdido (`is.na`)
  * NULL (_empty set_): elemento nulo de longitud 0 (`is.null`)
  * NaN (_not a number_): indeterminación con resultado desconocido (`is.nan`)
  * Inf (_infinite_): valor numérico de valor infinito (`is.infinite`)

Nota: A parte de estas funciones, `is.numeric` comprueba si la variable es numérica;  `is.finite` comprueba la existencia de cualquier valor especial en un vector numérico pero devuelve `FALSE` para variables de texto.

Reemplaza, en todas las columnas numéricas del data frame `dirty_iris`, los valores que sean especiales (usando `is.finite`), negativos, o iguales a cero, por `NA`. 
Nota: Puedes reemplazar los valores para cada variable del dataframe usando `mutate` con la función `ifelse`.

```{r Solucion ejercicio 2, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}
# DEBEMOS ELIMINAR TAMBIEN LOS VALORES IGUALES A CERO YA QUE SE TRATA DE LONGITUDES DE PARTES DE UNA FLOR. NO PUEDEN SER O

# DEBEMOS ELIMINAR TAMBIEN LOS VALROES IGUALES A CERO...

#clonamos dirty_iris para limpiar
dirty_iris_limpio<-dirty_iris

# 1. Identificar las columnas numéricas
#sapply devuelve TRUE/FALSE por cada columna
#which() nos da los indices de las que son TRUE
columnas_numericas_idx <- which(sapply(dirty_iris, is.numeric))

#para cada columna identificada como numerica
for (col_idx in columnas_numericas_idx) {
  
  #extraer la columna
  col_vector <- dirty_iris[[col_idx]] 
  
  #aplicar condicion, si para cada valor de esa columna, no es finito (es decir es inf,-inf,NaN, Na) o es cero, sustituir por NA sino, dejar el valor original
  col_limpia <- ifelse(!is.finite(col_vector) | col_vector <= 0, NA, col_vector)
  
  #Reemplazar la columna en el dataframe
  dirty_iris_limpio[[col_idx]] <- col_limpia
}

#ocmprobamos el resultado
summary(dirty_iris_limpio)


```


## Ejercicio 3: Valores perdidos y observaciones completas

  * Calcula el número y porcentaje de observaciones completas (muestras sin ningún dato perdido) empleando `complete.cases` (detecta todos los registros sin datos faltantes).
  * Emplea después la función `na.omit` para quedarnos solo con las filas con datos completos en un nuevo data frame `clean_iris`.

```{r Solucion ejercicio 3, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}

# complete.cases() devuelve un vector true/false segun si la fila esta completa o no
casos_completos_vec <- complete.cases(dirty_iris_limpio)

#Calculamos el número de casos completos
#sum() trata TRUE como 1 y FALSE como 0
num_completas <- sum(casos_completos_vec)

#Calculamos el número total de filas
total_filas <- nrow(dirty_iris_limpio)

#Calculamos el porcentaje
porcentaje_completas <- (num_completas / total_filas) * 100

print(paste("Número total de filas original: ", total_filas))
print(paste("Número de observaciones completas (sin NAs): ", num_completas))
print(paste("Porcentaje de observaciones completas: ", round(porcentaje_completas,2)," %"))


# na.omit() crea un nuevo dataframe eliminando cualquier fila que contenga al menos un NA.
clean_iris <- na.omit(dirty_iris_limpio)

print(paste("Dimensiones del nuevo df clean_iris: ", nrow(clean_iris)," filas", ncol(clean_iris)," columnas."))

# El número de filas de clean_iris debe ser igual a num_completas --> 92

summary(clean_iris) #ya no debe haber NAs
```

# Detección de outliers univariante

Un outlier es una observación (o conjunto de observaciones) que no parecen consistentes con el resto de valores de esa variable. Por lo general, esas observaciones divergirán del patrón de comportamiento del resto de datos, es decir, presentarán una desviación respecto de la distribución de los datos.

En esta sección, vamos a centrarnos en métodos de detección univariantes, así que, en los ejercicios, a modo de ejemplo, analizaremos solo la variable `Petal.Length`.

## Ejercicio 4: Estadísticos básicos

La presencia de outliers puede producir una gran influencia en caracterizaciones sencillas de los datos, como la media y la desviación típica.

Empleado la función `summarise y across`, calcula la media, la desviación típica, mediana, la  _median absolute deviation from the median_ (MADM) y el _interquartile range_ (IQR) de las variables numéricas. 
Hazlo para el data frame con observaciones completas `clean_iris` (que no tiene NA pero tiene menos observaciones) y para el data frame con datos faltantes `dirty_iris` (que presenta muchos NA pero tiene todas las observaciones).

  * Ten en cuenta que no se puede realizar un análisis estadístico con datos faltantes, pero en la mayoría de los casos se puede optar por no considerar dichos valores al realizar los cálculos (parámetro `na.rm=TRUE`).
  * Para obtener el valor MADM, escribe una función `madm(x)` que sea robusta a la presencia de valores NA. Recuerda que el MADM se calcula como $1.4826\cdot\textrm{median}(|x - \textrm{median(x)}|)$.
  * Compara los resultados para los dos conjuntos en la variable `Petal.Length`.

```{r , include = TRUE}
library(dplyr)
library(tidyr) # Para pivot_longer y separate

#Definir la función MADM robusta a NAs
#1.4826 * median(|x - median(x)|)
madm <- function(x) {
  mediana_x <- median(x, na.rm = TRUE)
  desviacion_abs <- abs(x - mediana_x)
  mediana_desv_abs <- median(desviacion_abs, na.rm = TRUE)
  madm_valor <- 1.4826 * mediana_desv_abs
  return(madm_valor)
}

#Creamos una lista con las fucniones a aplicar en cada columna
funciones_estadisticas <- list(
  media = ~mean(., na.rm = TRUE),
  sd = ~sd(., na.rm = TRUE),
  mediana = ~median(., na.rm = TRUE),
  madm = ~madm(.), 
  iqr = ~IQR(., na.rm = TRUE)
)

#Calcular estadísticos para clean_iris
stats_clean <- clean_iris %>%
  summarise(
    across(
      .cols = where(is.numeric), #sobre las columnas que sean numericas
      .fns = funciones_estadisticas,
      .names = "{.col}_{.fn}" #nombres de columnas como "Petal.Length_media"
    )%>%
      mutate(dataset = "clean_iris")
  ) 

#Calcular estadísticos para dirty_iris
stats_dirty <- dirty_iris %>%
  summarise(
    across(
      .cols = where(is.numeric),
      .fns = funciones_estadisticas,
      .names = "{.col}_{.fn}"
    )%>%
      mutate(dataset = "dirty_iris_con_NA")
  ) 

# Combinamos los dos df 
stats_combinados <- bind_rows(stats_clean, stats_dirty)

#Reordenamos la tabla
stats_formateados <- stats_combinados %>%
  #Pasamos de formato ancho a largo
  pivot_longer(
    cols = -dataset, #todas menos la identificadora del dataset 
    names_to = "variable_estadistico", 
    values_to = "valor"
  ) %>%
  #Separamos Petal.Length_media en Petal.Length (variable) y media (estadistico)
  separate(variable_estadistico, into = c("variable", "estadistico"), sep = "_") %>%
  #Pasamos las métricas a columnas para la tabla final
  pivot_wider(
    names_from = estadistico,
    values_from = valor
  )

#Mostrar la comparación para Petal.Length 
print("Comparación de Estadísticos para Petal.Length")

comparacion_petal <- stats_formateados %>%
  filter(variable == "Petal.Length")

# Imprimir la tabla de comparación
print(comparacion_petal)
```


## Ejercicio 5: Métodos de detección de outliers

Escribe una función que detecte los outliers de un vector $x$ para cada uno de los siguientes métodos de detección de outliers univariantes (todas las funciones tienen que ser robustas a la presencia de valores NA).

  * **Regla 3 sigma** `reglasigma(x)`: Considera que los datos siguen una distribución gaussiana. Datos típicos caracterizados por la media y la dispersión por la varianza. Valores por encima de 3 desviaciones típicas se consideran outliers.

  * **Identificador Hampel** `reglahampel(x)`: Utiliza estimadores robustos y no presupone que los datos siguen una distribución gaussiana. Datos típicos caracterizados por la mediana y la dispersión por la _median absolute deviation from the median_ (MADM). Valores por encima de 3 MADM se consideran outliers.

  * **Regla boxplot** `reglaboxplot(x)`: A partir de los datos se calcula su diagrama de caja (boxplot) y se definen como datos típicos superiores hasta el cuartil 75%, $x_s$; datos típicos inferiores hasta el cuartil 25%, $x_i$; y la dispersión se define como el rango intercuartílico ($IQR= x_s-x_i$). Valores por encima de $x_s+1.5\cdot IQR$ o por debajo de $x_i-1.5\cdot IQR$ se consideran outliers. Usa la función `quantile` para calcular los cuartiles.

  * **Percentiles** `reglapercentil(x)`: Cualquier valor que esté fuera del rango del percentil 5% y 95% se puede considerar como atípico. Usa la función `quantile` para calcular los percentiles.

```{r , include = FALSE}

# Regla 3 sigma
reglasigma <- function(x) {
  #Calcular media y desviación estándar, ignorando NAs
  media_x <- mean(x, na.rm = TRUE)
  sd_x <- sd(x, na.rm = TRUE)
  
  #Calcular límites superior e inferior
  limite_sup <- media_x + (3 * sd_x)
  limite_inf <- media_x - (3 * sd_x)
  
  #Devolver TRUE si el valor está fuera de los límites
  #La comparación con NA devolverá NA
  outliers <- (x > limite_sup) | (x < limite_inf)
  return(outliers)
}


# Identificador Hampel
reglahampel <- function(x) {
  #Calcular la mediana, ignorando NAs
  mediana_x <- median(x, na.rm = TRUE)
  
  #Calcular el MADM (robusto a NAs)
  #MADM = 1.4826 * median(|x - median(x)|)
  desviacion_abs <- abs(x - mediana_x)
  mad_x <- median(desviacion_abs, na.rm = TRUE)
  madm_x <- 1.4826 * mad_x
  
  #Calcular límites
  limite_sup <- mediana_x + (3 * madm_x)
  limite_inf <- mediana_x - (3 * madm_x)
  
  #Devolver TRUE si el valor está fuera de los límites
  outliers <- (x > limite_sup) | (x < limite_inf)
  return(outliers)
}


# Regla boxplot
reglaboxplot <- function(x) {
  #Calcular Q1 y Q3
  q1 <- quantile(x, 0.25, na.rm = TRUE)
  q3 <- quantile(x, 0.75, na.rm = TRUE)
  
  #Calcular el Rango Intercuartílico (IQR)
  iqr_x <- q3 - q1
  
  #Calcular los límites 
  limite_sup <- q3 + (1.5 * iqr_x)
  limite_inf <- q1 - (1.5 * iqr_x)
  
  #Devolver TRUE si el valor está fuera de los límites
  outliers <- (x > limite_sup) | (x < limite_inf)
  return(outliers)
}


# Percentiles
reglapercentil <- function(x) {
  #Calcular el percentil 5 y 95 
  limites <- quantile(x, c(0.05, 0.95), na.rm = TRUE)
  
  #Asignar límites
  limite_inf <- limites[1] # percentil 5
  limite_sup <- limites[2] # percentil 95
  
  #Devolver TRUE si el valor está fuera de los límites
  outliers <- (x < limite_inf) | (x > limite_sup)
  return(outliers)
}

```


## Ejercicio 6: Detección de outliers

Utiliza la función `mutate` y `across` para identificar los outliers en la variable `Petal.Length` con todos los métodos de detección de outliers implementados. Genera una columna nueva para cada método. 
Nota: podría extenderse la aplicación a todas las variables numéricas usando también `mutate`, `across` y `where`. 

```{r Solucion ejercicio 6, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}

#Creamos una lista con las funciones de outliers
funciones_outliers <- list(
  sigma = ~reglasigma(.),
  hampel = ~reglahampel(.),
  boxplot = ~reglaboxplot(.),
  percentil = ~reglapercentil(.)
)

#Usamos mutate() y across()
iris_con_outliers <- dirty_iris_limpio %>%
  mutate(
    across(
      .cols = Petal.Length, 
      .fns = funciones_outliers,    
      .names = "outlier_{.col}_{.fn}" 
    )
  )

#iris_con_outliers ahora tiene 16 columnas lógicas nuevas
#(4 variables * 4 métodos)
#glimpse(iris_con_outliers)

```

## Ejercicio 7: Comparativa de los métodos de detección de outliers

En los métodos de detección de outliers analizados, examina los resultados comparando:

  * Número de outliers detectados por método.
  * Los valores etiquetados como outliers (ordenados de menor a mayor).

```{r Solucion ejercicio 7, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}

print("Resumen de outliers detectados para Petal.Length")

#summary() en columnas lógicas (TRUE/FALSE) nos da un conteo de los detectados como outliers (TRUE) y los tipicos (FALSE)
iris_con_outliers %>% 
  select(starts_with("outlier_Petal.Length")) %>%
  summary()

#Valores etiquetados como outliers ordenados de menor a mayor

print("Valores de Petal.Length etiquetados como outliers ordenados")

#Filtramos para quedarnos con cualquier fila donde AL MENOS UNO de los métodos haya dado TRUE

#Seleccionamos las columnas de outliers 
columnas_outlier <- iris_con_outliers %>%
  select(starts_with("outlier_Petal.Length"))

#Calculamos la suma de TRUEs por fila
#na.rm=TRUE para que (FALSE y NA) sume 0 
suma_outliers_por_fila <- rowSums(columnas_outlier, na.rm = TRUE)

#Filtramos el df original donde la suma fue > 0, es decir, algun metodo detecto un outlier
valores_outliers <- iris_con_outliers %>%
  filter(suma_outliers_por_fila > 0) %>%
  select(Petal.Length, starts_with("outlier_Petal.Length")) %>%
  arrange(Petal.Length)

print(valores_outliers) 
```

## Ejercicio 8: Representación gráfica

Representa gráficamente los datos de `Petal.Length` (distribución de puntos en el eje $y$) para todas las reglas de detección implementadas (repartidas en el eje $x$) mostrando los valores identificados como típicos y los identificados como outliers en diferente color. Usa la función `pivot_longer` para poder agrupar por reglas y colorear los outliers fácilmente.

Nota: usa en `geom_point` con la opción `position='jitter'` para mejorar la legibilidad del gráfico.

```{r Solucion ejercicio 8, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}
library(ggplot2)

#El objetivo es tener una columna 'metodo_outlier' y una columna 'es_outlier'
df_grafico <- iris_con_outliers %>%
  # Seleccionamos solo Petal.Length y sus columnas de outlier
  select(Petal.Length, starts_with("outlier_Petal.Length")) %>%
  
  # Transformamos las columnas de outlier en filas
  pivot_longer(
    cols = starts_with("outlier_Petal.Length"), #Las columnas a pivotar
    names_to = "metodo_outlier",                 #Nueva columna para el nombre del método
    values_to = "es_outlier"                     #Nueva columna para el valor TRUE/FALSE
  ) %>%
  #Cambiamos el nombre de metodo eliminando la parte de outlier_Petal.Length_ y dejando solo el nombre del metodo
  mutate(
    metodo_outlier = gsub("outlier_Petal.Length_", "", metodo_outlier),
  ) %>%
  #Convertimos NAs a FALSE para que no se coloreen como outliers
  mutate(es_outlier = ifelse(is.na(es_outlier), FALSE, es_outlier))

ggplot(df_grafico, aes(x = metodo_outlier, y = Petal.Length, color = es_outlier)) +
  geom_point(position = position_jitter(width = 0.3)) + #resuelve un problema de overplotting.
#Su función es añadir una pequeña cantidad de "ruido" aleatorio a la posición de cada punto.

  scale_color_manual(values = c("FALSE" = "black", "TRUE" = "red"),
                     labels = c("Típico", "Outlier")) +
  labs(
    title = "Detección de Outliers en Petal.Length por Método",
    x = "Método de Detección de Outlier",
    y = "Petal.Length",
    color = "¿Es outlier?") 
```

# Imputación de datos

Como se ha visto, con _missing data_ nos referimos a una observación (o conjunto de observaciones) cuyo valor no es conocido. 

Vamos a ver a continuación ejemplos de cómo imputar valores realistas a esas observaciones perdidas.

## Ejercicio 9: Imputación de datos perdidos con estadísticos básicos

La opción más sencilla es imputar con un valor estimado de los valores conocidos (por ejemplo, con la media, la mediana, o la moda).

Se puede realizar una imputación generalizada (usando todos los valores de la variable) o una imputación a partir de casos similares (la estimación se realiza teniendo en cuenta otra variable):

  * Imputa los missing data en `Petal.Length` empleando la media. Nota: Puedes reemplazar los valores vacios usando `mutate` con `ifelse` creando una nueva variable `Petal.Length1`.

```{r Solucion ejercicio 9a, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}

#Calcular la media general de Petal.Length (ignorando NAs)
media_general <- mean(dirty_iris_limpio$Petal.Length, na.rm = TRUE)

print(paste("La media de Petal.Length es:", media_general))

#Imputar NAs con la media 
iris_imputado_media <- dirty_iris_limpio %>%
  mutate(
    Petal.Length1 = ifelse(is.na(Petal.Length),  #Si Petal.Length es NA
                           media_general,       #usa la media general
                           Petal.Length)        #si no deja el valor original
  )

#Mostramos las filas que antes eran NA
print("Filas imputadas con la media general")
iris_imputado_media %>%
  filter(is.na(dirty_iris_limpio$Petal.Length)) %>% 
  select(Species,Petal.Length, Petal.Length1) 
```

  * Imputa los missing data en `Petal.Length` empleando en esta ocasión la media para cada tipo de `Species` (usar`group_by` y `mutate`) creando una nueva variable `Petal.Length2`.

```{r Solucion ejercicio 9b, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}

#Imputar NAs usando la media de cada grupo Species
iris_imputado_media_species <- dirty_iris_limpio %>%
  group_by(Species) %>% #Agrupamos por especie
  mutate(
    #ahora calcula la media 
    #solo para el grupo de especies de esa fila
    Petal.Length2 = ifelse(is.na(Petal.Length),
                           mean(Petal.Length, na.rm = TRUE),
                           Petal.Length)
  ) %>%
  ungroup() 


print("Verificación: Filas imputadas con la media del grupo Species")
iris_imputado_media_species %>%
  filter(is.na(dirty_iris_limpio$Petal.Length)) %>%
  select(Species, Petal.Length, Petal.Length2) 

#Podemos tb ver las medias que se usaron para cada grupo
print("Medias usadas para la imputación por especie")
iris_imputado_media_species %>%
  group_by(Species) %>%
  summarise(Media_Grupo = first(Petal.Length2[is.na(Petal.Length)])) #"Para cada Species, encuentra una fila que solía ser NA en Petal.Length, y dime que valor le pusimos en Petal.Length2". First solo coge el primer valor del vector de cada grupo.

```

## Ejercicio 10: Representación gráfica

Vamos a comparar ahora los dos métodos de imputación gráficamente eliminando los outliers para una mejor visualización.

  * Recalcula las reglas de identificación de outliers (Ejercicio 6) para la nueva variable `Petal.Length2`.
  
```{r Solucion ejercicio 10a, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}

 
```

  * Representa los dos tipos de imputación empleados en un gráfico de dispersión (`Petal.Length1` vs. `Petal.Length2`) eliminando los outliers identificados con la regla `reglapercentil` y poniendo en diferente color los datos originales y los imputados.

```{r Solucion ejercicio 10b, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}



```



